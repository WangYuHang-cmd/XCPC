## 环形DP与后效性

环形DP的两种常用解决思路：

- 策略1. 破环成链，然后对于延长一倍的地方同样进行DP
- 策略2. 二次DP或者多次DP补全状态



### 策略1





### 策略2

288. #### 休息时间

> 一天n个小时规定要休息满m个小时，但是每次休息前1个小时不能恢复体力。可以从前一天的比如24点休息到第二天的某一时刻，也算作一个循环。问最多能恢复多少点体力

- 状态方程 

> $f[i][j][0]$前i天休息了j小时且当前不在休息
>
> $f[i][j][1]$前i天休息j小时且当前在休息

- 状态转移

> $f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1])$
>
> $f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j-1][1]+s[i])$ 由不休息转移过来不能回复，又休息转移过来能恢复

- 初始化  因为不能同时保证1时刻能休息和1时刻不能休息，因此要分别计算，然后取max

> 情况1：不考虑跨天休息
>
> ```cpp
> memset(f,-0x3f,sizeof f);
> f[0][0][0]=0;
> /*..循环..*/
> ans = max({ans, f[n][m][0], f[n][m][1]});
> ```
>
> 情况2：强制跨天休息
>
> ```cpp
> memset(f,-0x3f3f3f3f,sizeof f);
> f[1][1][1]=s[1];
> /*循环的时候从i=2开始...*/
> ans = max(ans, f[n][m][1]); //注意不能选择第n天不休息的，因为强制跨天休息，因此第n天必须休息
> ```
>
> 