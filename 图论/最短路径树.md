## 最短路径树

对于某个结点`V`，其最短路径树是以`V`为根节点向外延申，其余没一点到`V`的距离都是最短距离的树形结构

注意，最短路径树与最小生成树并不相同，以下是例子：

**原图**：

![image-20211111232108540](C:\Users\Henry\AppData\Roaming\Typora\typora-user-images\image-20211111232108540.png)

**最短路径树**

![image-20211111232257484](C:\Users\Henry\AppData\Roaming\Typora\typora-user-images\image-20211111232257484.png)

**最小生成树**

![image-20211111232309386](C:\Users\Henry\AppData\Roaming\Typora\typora-user-images\image-20211111232309386.png)

>所谓最短路径树，就是从s出发，沿着树上的边走到任意点i，那么经过的这些边的权值和就是s到i的最短路径。Dijkstra算法或SPFA算法不仅可计算从起点s到各点的最短路径长度，同时也可得到以s为根的最短路径树。方法是在进行松弛操作时，如果d[i] + c < d[j] 时，除了更新d[j]之外，还要设置fa[j]=i。这样把fa[j]看成j的父亲指针，则所有点形成了一棵树（因为每个结点都有唯一的前驱）。这样要从起点s出发沿最短路走到任意点，只需要顺着树边走即可。

#### 最短路径图的构造方法

>n个城市用m条双向公路连接，使得任意两个城市都能直接或间接地连通。其中城市编号为1..n，公路编号为1..m。
>任意个两个城市间的货物运输会选择最短路径，把这n*(n-1)条最短路径的和记为S。现在你来寻找关键公路r，公
>路r必须满足：当r堵塞之后，S的值会变大（如果r堵塞后使得城市u和v不可达，则S为无穷大）。



#### 最短路径树的个数:

```cpp
设 D[i] 为如果所有的通道都被修建，第 i 号房间与第 1 号房间的最短路径长度；而 S[i] 为实际修建的树形城堡中第 ii 号房间与第 1 号房间的路径长度；要求对于所有整数 i，有 S[i]=D[i] 成立。

为了打败 Lord lsp，lqr 想知道有多少种不同的城堡修建方案。

你需要输出答案对 2^31–1 取模之后的结果。
```

在使用`prim`算法的时候顺便记录每个点到当前点t距离满足以下等式的点的个数
$$
dist(u) = dist(v) + w(v,u)
$$
然后累加到对应个数中

对于每一步，每一个新点连进来，对于已经联通的连通块中的所有的点满足上述式子的点的个数记为`ai`，由乘法原理，我们可以得到最小路经树的所有方法数为`a1*a2*...*an`

