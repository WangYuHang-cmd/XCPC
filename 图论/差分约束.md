### 差分约束

1.可以用来求一个不等式组的可行解

2.可以求最大值或者最小值
$$
方程形如x_i \lt x_j+c_k:
$$

$$
\begin{cases}
        x_1 \le x_2 +c_1\\
        x_2 \le x_3 +c_2 \\ 
        x_3 \le x_4 +c_3 \\
        ...\\
        x_n \le x_{n+1} +c_n  \\
    \end{cases}\\
c_1,c_2...c_n为常量
$$

对于每一个不等式
$$
x_i \le x_j + c_k
$$
我们可以借助最短路模型中的三角不等式
$$
dits[i] \le dist[j] + c
$$
` j `和` i `对应两个点，之间的长度对应常数`c`.

因此借助此性质建图，我们只需任取超级源点（此源点出发要能遍历所有边，因此考虑超级源点）进行遍历，得到的每一个点到起点的最短路径即为对应可行解。

#### 总结:

[1]先将每一个不等式转化为从$x_j$走到$x_i$,长度为c的一条边

[2]找一个超级源点使得该点能够遍历到所有边

[3]从源点求一遍单源最短路

[4]对于形如xi<=c的转化方式：建立一个虚拟源点，等价于
$$
x_i \le x_0+c\\
x_0=0
$$

#### 结果：

[1]如果存在负环，原不等式组一定无解

[2]如果没有负环，则 dist[i]就是原不等式组的一个解

##### 求最大可行解与最小可行解

结论1：如果求的是最小值，则应该使用最长路(ge)

结论2：如果求的是最大值，则应该使用最短路(le)

*结论2证明：*倘若求Xi的最大值，即求出Xi的所有上界取最小值，即等于最短路径的长度,使用≤号来规范



小技巧：如果发现超时了有两种Debug技巧

1.检查数组是不是开小了

2.将SPFA中的队列改成栈

3.记住，一定是从小的向大的连边，以大于为例，a>=b+c表示从b向a连一条长度为c的边（最长路）a<=b+c表示从b向a连一条长度为c的边（最短路）

```cpp
bool spfa(){
    int res=0;
    memset(dist,-0x3f,sizeof dist);
    dist[0]=0;

    stack<int> Q;
    Q.push(0);

    while(Q.size()){
        int t=Q.top();
        Q.pop();
        st[t]=false;

        for(int i=h[t];~i;i=ne[i]){
            int j=e[i];
            if(dist[j]<dist[t]+w[i]){
                dist[j]=dist[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>n) return false;
                if(!st[j]){
                    Q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return true;
}
```

对于差分约束有三种做法：

```cpp
以求最长路为例：
[1]边权无限制	SPFA	O(km~nm)
[2]边权非负		Tarjan
[3]边权为正		拓扑序计算最长路
```



