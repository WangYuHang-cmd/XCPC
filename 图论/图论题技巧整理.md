## 图论题技巧整理

##### 最短路径模型

1.建立虚拟源点

- 虚拟远点的建立可以将点权转化为边权
- 对于多个起点，一个终点的情况，也可以建立虚拟源点。从源点向每个起点出发连接一条长度为0的边。这样就可以转化为从虚拟源点出发，能到达中点的最短路径

2.记录路径（将dist[] 数组开至二维）

- 对于按照某一顺序访问多个节点的题目可以先遍历记录路径，再使用DFS()根据全排列求解

3.将边权进行0，1转换

- 对于求第k+1大的路径或者求最大的路径使得某某条件最小时，可以配合二分，将所有边权分类为1和0来进行求解(分类)

4.对于不同连通块，内部只有正权边，外部由负权边构成的图

- 按照拓扑序做堆优化的Dijkstra算法。由于按照拓扑序列，因此保证了到每一点的距离都为最小

5.考虑建立反向边

- 当起点有多个而只有一个确定的终点时，应当考虑建立反向边

6.正反各进行遍历

- 对于在途中买卖一次商品的题目，考虑正反都进行遍历，然后最后使用DP的思想来划分集合，然后求解

7.拆点

将dist数组扩展至二维，来存储点的不同性质（类似于DP）。例如寻找最短路径和次短路径的时候可以选择拆点

8.有负权边，求在最短路径条数：

- 先使用SPFA求出所有最短路径，枚举所有t->j的边w[i]，判断每个边是否满足:
  $$
  dist[j]==dist[t]+w[i]
  $$

- 

9.求最短路径条数：

- 使用Dijkstra算法或者BFS能够保证拓扑序。在更新最短距离的时候顺便记录一下条数即可

10.恰好经过k条路的最短路径

- 1.快速幂+类Floyd算法

$$
d[a+b,i,j]=min(d[a+b,i,j],d[a,i,k]+d[b,k,j])
$$

- 2.bellman_ford算法



##### 最小生成树模型

1.建立超级源点

便于将点权转化为边权

2.次小生成树

定义：给一个带权图，把图中所有生成树按权值从小到大排序，第二小的成为次小生成树

- 有两种定义方式，一种是按照排列定义的第二小，因此可能数值与最小生成树一样。第二种是严格次小生成树，即严格小于最小生成树

**方法1**：先求最小生成树，再枚举删除最小生成树的边求解,时间复杂度为：
$$
O(mlogm+nm)
$$
劣势：不容易求严格最小生成树

*证明* 设T为图G的一颗生成树，对于非树边a和非树边b，插入边a，并删除边b的操作记为(+a,-b)

如果T+a-b之后仍然是一颗生成树，称(+a,-b)是T的一个可行交换

称由T进行依次可行变换所得到的新的生成树集合为T的邻集，次小生成树一定在最小生成树的邻集当中。

**方法2**：先求最小生成树，然后依次枚举非树边，然后将改边加入树中，同时从树中去掉一条边，使得最终的图仍是一棵树
$$
O(m+n^2+mlogm)
$$
可用树上倍增LCA优化至
$$
Q(m+mlogn+mlogm)
$$


##### 基于SPFA求负环

1.统计每个点入队的次数，如果某个点入队n次说明存在负环

2.统计每个点的最短路中所包含的边数，如果某个点的最短路所包含的边数大于等于n，则也说明存在负环

但是由于SPFA判断负环的时间复杂度比较高，约O(nm)，因此有一种较为取巧的方式：
$$
当所有点的被更新的迭代次数超过2n(尽量开大)时，我们就认为大概率图中有负环
$$

##### 01分数规划

图论问题形如求
$$
\frac{\Sigma{f_i}}{\Sigma{t_i}}的最大值
$$
为01分数规划，一般思路：**二分**比值,然后判断图中是否存在正环

